(def include? (thing things)
  ; alias for 'detect
  ; true if thing is in things, nil otherwise
  (detect thing things))

(def sort-by (f things)
  ; sort 'things according to the value
  ; returned by 'f for each thing in 'things
  (let tmp (hash)
    (each thing things
          (hash-cons tmp
                    (f thing)
                    thing))
    (apply joinlists
           (map λx(hash-get tmp x)
                (sort:hash-keys tmp)))))

(def mapsum (f things)
  ; map 'f over 'things and sum the resulting list
  (apply + 0.0 (map f things)))

(def hash-values (h)
  ; return values for each key in hash 'h
  (map (fn (k) h.,k) (hash-keys h)))

(def seen? ()
  ; returns a new function f which takes a parameter x
  ; for each call to f with any value Z for x
  ; f returns true if this f has previously seen Z
  ; f returns nil otherwise.
  ; Note that each call to 'seen? returns a new function with
  ; its own history independent of previous calls to 'seen?
  (let seen (hash)
    λx(returning seen.,x (= seen.,x t))))

(def uniqify (things)
  ; return a list containing all the elements of 'things, but with no duplicates
  (reject (seen?) things))

(def group-by (f things)
  ; return a hash of 'things keyed by (f thing) for
  ; each thing in 'things
  (returnlet hsh {}
    (each thing things
          (hash-cons hsh (f thing) thing))))

(with (m2i λd(+ (* 12 d.year) (- d.month 1))
       i2m λi(date (/ i 12) (+ 1 (mod i 12)) 1))
      (def relative-months (anchor . mm)
        ; 'anchor is a date
        ; 'mm is a list of integers
        ; for each m in 'mm, return the date at the beginning of
        ; the month given by adding m months to 'anchor
        (let mi (m2i anchor)
          (map λm(i2m (+ mi m)) mm))))

(mac auto-hash names
  ; (auto-hash a b c) same as { a a b b c c }
  `(brace-list ,@(flatten:map λn(list n n) names)))
