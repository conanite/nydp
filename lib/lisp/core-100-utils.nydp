(def include? (thing things)
  ; alias for 'detect
  ; true if thing is in things, nil otherwise
  (detect thing things))

(def sort-by (f things)
  ; sort 'things according to the value
  ; returned by 'f for each thing in 'things
  (let tmp (hash)
    (each thing things
          (hash-cons tmp
                    (f thing)
                    thing))
    (apply joinlists
           (map λx(hash-get tmp x)
                (sort:hash-keys tmp)))))

(def mapsum (f things)
  ; map 'f over 'things and sum the resulting list
  (apply + 0.0 (map f things)))

(def hash-values (h)
  ; return values for each key in hash 'h
  (map (fn (k) h.,k) (hash-keys h)))

(def seen? ()
  ; returns a new function f which takes a parameter x
  ; for each call to f with any value Z for x
  ; f returns true if this f has previously seen Z
  ; f returns nil otherwise.
  ; Note that each call to 'seen? returns a new function with
  ; its own history independent of previous calls to 'seen?
  (let seen (hash)
    λx(returning seen.,x (= seen.,x t))))
