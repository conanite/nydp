; -*- lisp -*-

(assign last-cons (fn (xs)
                      (cond (pair? (cdr xs))
                            (last-cons (cdr xs))
                            xs)))

(assign last (fn (xs)
                 (car (last-cons xs))))

(assign append-list! (fn (list-1 list-2)
                         (cdr-set (last-cons list-1) list-2)
                         list-1))

(assign list (fn args args))

(assign caar (fn (arg) (car (car arg))))
(assign cadr (fn (arg) (car (cdr arg))))
(assign cddr (fn (arg) (cdr (cdr arg))))
(assign   no (fn (arg) (eq? arg nil)))
(assign just (fn (arg) arg))

(assign mac-expand (fn (macfn name body)
  (cond macfn
        (pre-compile-do (apply macfn body))
        (cons name body))))

(assign macs (hash))

(assign debug-pre-compile
        (fn (arg)
            (assign *debug-pre-compile* arg)))

(assign pre-compile-expr
        (fn (name body)
            (mac-expand (hash-get macs name) name body)))

(assign pre-compile-each
        (fn (args)
            (cond args
                  (cond (pair? args)
                        (cons (pre-compile-do (car args))
                              (pre-compile-each (cdr args)))
                        args))))

(assign pre-compile-msg
        (fn args
            (cond *debug-pre-compile* (apply p args) (car args))))

(assign pre-compile-do
        (fn (arg)
            (cond (pair? arg)
                  (cond (eq? (car arg) 'quote)
                        arg
                        (pre-compile-each (pre-compile-expr (car arg) (cdr arg))))
                  arg)))

(assign pre-compile
        (fn (arg)
            (pre-compile-msg "pre-compile" arg)
            (pre-compile-msg (pre-compile-do arg))))

(hash-set macs 'def
          (fn (name args . body)
              (list 'assign
                    name
                    (+ (list 'fn args)
                       body))))

(def qq-handle-unquote-splicing (arg rest level)
     (cond (no rest)
           arg
           (list '+
                 arg
                 (qq-quasiquote rest level))))

(def qq-handle-quasiquote (arg rest level)
     (list 'cons
           (list 'quasiquote (qq-quasiquote arg level))
           (qq-quasiquote rest level)))

(def qq-handle-unquote (arg rest level)
     (list 'cons
           (qq-maybe-unquote arg level)
           (qq-quasiquote rest level)))

(def qq-unquote-recurse (arg rest level)
        (list 'cons
              (qq-quasiquote arg level)
              (qq-quasiquote rest level)))

(def qq-handle-plain (arg rest level)
     (list 'cons
           (list 'quote arg)
           (qq-quasiquote rest level)))

(def qq-unquote? (arg rest level)
     (cond (pair? arg)
           (cond (eq? (car arg) 'unquote)
                 (qq-handle-unquote (cadr arg) rest level)
                 (cond (eq? (car arg) 'unquote-splicing)
                       (qq-handle-unquote-splicing (cadr arg) rest level)
                       (cond (eq? (car arg) 'quasiquote)
                             (qq-handle-quasiquote (cadr arg) rest level)
                             (qq-unquote-recurse arg rest level))))
           (qq-handle-plain arg rest level)))

(def qq-maybe-unquote (xs level)
     (cond (eq? level 0)
           xs
           (list 'unquote (qq-quasiquote xs (- level 1)))))

(def qq-quasiquote (xs level)
     (cond (no xs)
           nil
           (cond (pair? xs)
                 (cond (eq? (car xs) 'unquote)
                       (qq-maybe-unquote (cadr xs) level)
                       (cond (eq? (car xs) 'quasiquote)
                             (cons 'quasiquote (qq-quasiquote (cdr xs) (+ level 1)))
                             (qq-unquote? (car xs) (cdr xs) level)))
                 (list 'quote xs))))

(hash-set macs 'quasiquote (fn (arg)
  (qq-quasiquote arg 0)))

(hash-set macs 'mac (fn (name args . body)
  `(hash-set macs ',name (fn ,args ,@body))))

(mac if args
     (cond (no args) nil
           (cond (cdr args)
                 (cond (cddr args)
                       `(cond ,(car args) ,(cadr args) (if ,@(cddr args)))
                       `(cond ,(car args) ,(cadr args)))
                 (car args))))

(mac and args
  (if args
      (if (cdr args)
          `(if ,(car args) (and ,@(cdr args)))
          (car args))
      't))

(mac do args
  `((fn nil ,@args)))

(mac when (condition . body)
  `(cond ,condition (do ,@body)))

(def print-and-return args
     (apply p args)
     (last args))

(def map (f things)
  (if (no things)
      nil
    (pair? things)
    (cons (f (car things)) (map f (cdr things)))
    (map f (list things))))

(def pairs (things)
     (if (no things)       nil
       (no (cdr things)) (list (list (car things)))
       (cons (list (car things) (cadr things))
             (pairs (cddr things)))))

(mac with (parms . body)
     `((fn ,(map car (pairs parms))
           ,@body)
       ,@(map cadr (pairs parms))))

(mac let (var val . body)
     `(with (,var ,val) ,@body))

(def each (f acc things)
  (if things
      (each f (f acc (car things)) (cdr things))
      acc))

(def eachr (f things)
     (when things
       (eachr f (cdr things))
       (f (car things))))

(def zip (a b)
  (if a
      (cons (list (car a) (car b))
            (zip (cdr a) (cdr b)))))

(mac push (x things)
  `(assign ,things (cons ,x ,things)))

(def flatten (things)
     (let acc nil
          (let flattenize nil
               (assign flattenize (fn (x)
                                      (if (pair? x)
                                          (eachr flattenize x)
                                        (push x acc))))
               (flattenize things))
          acc))

(def joinstr (txt things)
     (if (no (pair? things))
         (error "joinstr : 'things is a %%(type-of things) expected a list : %%(inspect things)"))
     (apply +
            (to-string (car things))
            (flatten (zip (map (fn (_) txt) (cdr things))
                          (map to-string (cdr things))))))

(let uniq-counter 0
     (def uniq (prefix)
          (sym (joinstr "-"
                        (list prefix
                              (assign uniq-counter
                                      (+ uniq-counter 1))))))
     (def reset-uniq-counter ()
          (assign uniq-counter 0)))

(mac w/uniq (vars . body)
     (if (pair? vars)
         `(with ,(apply + (map (fn (n) (list n '(uniq ',n))) vars))
                ,@body)
       `(let ,vars (uniq ',vars) ,@body)))

(mac or args
     (cond args
           (w/uniq ora
                   `(let ,ora ,(car args)
                         (cond ,ora ,ora (or ,@(cdr args)))))))

(mac pop (xs)
     (w/uniq gp
             `(let ,gp (car ,xs)
                   (assign ,xs (cdr ,xs))
                   ,gp)))

(def nth (n things)
     (if (eq? n 0)
         (car things)
       (nth (- n 1) (cdr things))))

(def iso (x y)
     (or (eq? x y)
         (and (pair? x)
              (pair? y)
              (iso (car x) (car y))
              (iso (cdr x) (cdr y)))))

(def isa (type obj) (eq? (type-of obj) type))
(mac just (arg) arg)
(def quotify (arg) `(quote ,arg))

(def len (xs)
  (if (pair? xs)
      (+ 1 (len (cdr xs)))
      0))

(def build-keyword-args (pairs)
  (map (fn (ab) `(list (quote ,(car ab)) ,@(cdr ab))) pairs))
