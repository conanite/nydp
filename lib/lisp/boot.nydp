; -*- lisp -*-

(assign last-cons (fn (xs)
  (cond (pair? (cdr xs))
        (last-cons (cdr xs))
        xs)))

(assign append-list! (fn (list-1 list-2)
  (cdr-set (last-cons list-1) list-2)
  list-1))

(assign list (fn args args))

(assign caar (fn (arg) (car (car arg))))
(assign cadr (fn (arg) (car (cdr arg))))
(assign cddr (fn (arg) (cdr (cdr arg))))
(assign   no (fn (arg) (eq? arg nil)))

(assign mac-expand (fn (macfn name body)
  (cond macfn
        (pre-compile (apply macfn body))
        (cons name body))))

(assign macs (hash))

(assign pre-compile-expr (fn (name body)
  (mac-expand (hash-get macs name) name body)))

(assign pre-compile-each (fn (args)
  (cond args
        (cond (pair? args)
              (cons (pre-compile (car args))
                    (pre-compile-each (cdr args)))
              args))))

(assign pre-compile
        (fn (arg)
            (cond (pair? arg)
                  (cond (eq? (car arg) 'quote)
                        arg
                        (pre-compile-each (pre-compile-expr (car arg) (cdr arg))))
                  arg)))

(hash-set macs 'def (fn (name args . body)
  (list 'assign name (append-list! (list 'fn args) body))))

; arg is "(unquote x)"
; rest is another form
; returns (list 'cons x (qq-quasiquote rest))
(def qq-unquote-unq (arg rest)
  (list 'cons (cadr arg) (qq-quasiquote rest)))

(def qq-unquote-recurse (arg rest)
        (list 'cons
              (qq-quasiquote arg)
              (qq-quasiquote rest)))

(def qq-unquote? (arg rest)
     (cond (pair? arg)
           (cond (eq? (car arg) 'unquote)
                 (qq-unquote-unq arg rest)
                 (cond (eq? (car arg) 'unquote-splicing)
                       (list 'append-list!
                             (cadr arg)
                             (qq-quasiquote rest))
                       (qq-unquote-recurse arg rest)))
           (list 'cons
                 (list 'quote arg)
                 (qq-quasiquote rest))))

(def qq-quasiquote (xs)
     (cond (no xs)
           nil
           (cond (pair? xs)
                 (cond (eq? (car xs) 'unquote)
                       (cadr xs)
                       (qq-unquote? (car xs) (cdr xs)))
                 xs)))

(hash-set macs 'quasiquote (fn (arg)
  (qq-quasiquote arg)))

(hash-set macs 'mac (fn (name args . body)
  `(hash-set macs ',name (fn ,args ,@body))))

(mac if args
     (cond (no args) nil
           (cond (cadr args)
                 (cond (cddr args)
                       `(cond ,(car args) ,(cadr args) (if ,@(cddr args)))
                       `(cond ,(car args) ,(cadr args)))
                 (car args))))

(mac do args
  `((fn nil ,@args)))

(mac when (condition . body)
  `(cond ,condition (do ,@body)))

(def map (f things)
  (if (no things)
      nil
    (pair? things)
    (cons (f (car things)) (map f (cdr things)))
    (map f (list things))))

(def pairs (things)
     (if (no things)       nil
       (no (cdr things)) (list (list (car things)))
       (cons (list (car things) (cadr things))
             (pairs (cddr things)))))

(mac with (parms . body)
     `((fn ,(map car (pairs parms))
           ,@body)
       ,@(map cadr (pairs parms))))

(mac let (var val . body)
     `(with (,var ,val) ,@body))

(def each (f acc things)
  (if things
      (each f (f acc (car things)) (cdr things))
      acc))

(def eachr (f things)
     (when things
       (eachr f (cdr things))
       (f (car things))))

(def zip (a b)
  (if a
      (cons (list (car a) (car b))
            (zip (cdr a) (cdr b)))))

(def flatten (things)
  (let acc nil
       (let flattenize nil
            (assign flattenize (fn (x)
                                   (if (pair? x)
                                       (do
                                           (eachr flattenize (cdr x))
                                           (flattenize (car x)))
                                     (assign acc (cons x acc)))))
            (flattenize things))
       acc))

(def joinstr (txt things)
     (apply +
            (to-string (car things))
            (flatten (zip (map (fn (_) txt) (cdr things))
                          (map to-string (cdr things))))))

(def uniq (prefix)
     (joinstr "-" (list prefix (millisecs))))

(mac push (x things)
  `(assign ,things (cons ,x ,things)))

(mac fpop (xs)
  (w/uniq gp
  `(let ,gp (car ,xs)
     (assign ,xs (cdr ,xs))
     ,gp)))
