(chapter-start 'list-manipulation "utilities for manipulating and iterating over lists, including filters and transforms")

(def zip args
  ; takes a list of lists, ((p q r) (1 2 3) (a b c) ...), returns ((p 1 a ...) (q 2 b ...) (r 3 c ...))
  (if (car args)
      (cons (map car args)
            (apply zip (map cdr args)))))

; invokes 'f for each element of 'things, first element processed first
; ( "l" in "eachl" = "leftmost first" )
(def eachl (f things)
  (loop (pair? things)
        (do
            (f (car things))
            (= things (cdr things)))))

;; if things is a pair,
;;   if (cdr things) is nil, return (car things)
;;   else recurse on (cdr things)
;; else return things
;;
;; 'it is used internally
;;
(def list/last (things it)
  (loop (pair? things)
        (= it     (car things)
           things (cdr things)))
  (or things it))

;; finds the index of 'it in a list 'things, such that for example,
;; given a list 'my-list and an item 'thingy in the list,
;; (nth (list/index-of my-list thingy) my-list) will return the value of thingy
(def list/index-of (things it)
  (with (found nil
         i     -1)
    (loop (and things
               (no found))
     (= found  (eq? (car things) it)
        things (cdr things)
        i      (+ i 1)))
    (and found i)))

;; finds the item before and the item after the given item in the  given list.
;; For example,
;; (list/around '(a b c d e f) 'd) will return '(c e)
(def list/around (things it)
  (with (n    (list/index-of things it)
         n1   (and n (+ n 1))
         prev (and n
                   (> n 0)
                   (nth (- n 1) things))
         next (and n
                   (< n1 (len things))
                   (nth n1 things)))
    (list prev next)))

; invokes 'f for each element of 'things, last element processed first
; ( "r" in "eachr" = "rightmost first" )
(def eachr (f things)
  (eachl f (rev things)))

; assign (cons x things) to things
(mac push (x things) `(= ,things (cons ,x ,things)))

;; used internally by 'flatmap
(def flatmap-helper (f things res)
  (loop (pair? things)
    (let a (car things)
      (= res
         (if (pair? a)
             (flatmap-helper f a res)
             a
             (cdr-set res (cons (f a)))
             res)
         things
         (cdr things))))
  (if things
      (= res (set-cdr res (f things))))
  res)

;; flatten the given list, transforming each leaf-item, recursively
(def flatmap (f things)
  (let res (cons)
    (flatmap-helper f things res)
    (cdr res)))

; flatten the given list, recursively
(def flatten (things) (flatmap x1 things))

; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
; a 'key, returns the list (kx vx) from 'al where kx is equal to 'key
; #attribution: inspiration from arc.arc
(def assoc (key al)
  (if (pair? al)
      (if (caris key (car al))
          (car al)
          (assoc key (cdr al)))))

; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
; a 'key, returns vx from 'al where kx is equal to 'key
; #attribution: lifted almost directly from arc.arc
(def alref (key al) (cadr (assoc key al)))
