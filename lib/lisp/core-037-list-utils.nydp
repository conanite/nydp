(chapter-start 'list-manipulation "utilities for manipulating and iterating over lists, including filters and transforms")

(def zip args
  ; takes a list of lists, ((p q r) (1 2 3) (a b c) ...), returns ((p 1 a ...) (q 2 b ...) (r 3 c ...))
  (if (car args)
      (cons (map car args)
            (apply zip (map cdr args)))))

(def eachr (f things)
     (when things
       (eachr f (cdr things))
       (f (car things))))

(mac push (x things)
  ; assign (cons x things) to things
  `(= ,things (cons ,x ,things)))

(def flatten (things)
  ; flatten the given list, recursively
     (let acc nil
          (rfnwith flattenize (x things)
                   (if (pair? x)
                       (eachr flattenize x)
                       (push x acc)))
          acc))

(def assoc (key al)
  ; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
  ; a 'key, returns the list (kx vx) from 'al where kx is equal to 'key
  ; #attribution: inspiration from arc.arc
  (if (pair? al)
      (if (caris key (car al))
          (car al)
          (assoc key (cdr al)))))

(def alref (key al)
  ; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
  ; a 'key, returns vx from 'al where kx is equal to 'key
  ; #attribution: lifted almost directly from arc.arc
  (cadr (assoc key al)))
