(chapter-start 'list-manipulation "utilities for manipulating and iterating over lists, including filters and transforms")

(def zip args
  ; takes a list of lists, ((p q r) (1 2 3) (a b c) ...), returns ((p 1 a ...) (q 2 b ...) (r 3 c ...))
  (if (car args)
      (cons (map car args)
            (apply zip (map cdr args)))))

; invokes 'f for each element of 'things, first element processed first
; ( "l" in "eachl" = "leftmost first" )
(def eachl (f things)
  (loop (pair? things)
        (do
            (f (car things))
            (= things (cdr things)))))

;; if things is a pair,
;;   if (cdr things) is nil, return (car things)
;;   else recurse on (cdr things)
;; else return things
;;
;; 'it is used internally
;;
(def list/last (things it)
  (loop (pair? things)
        (= it     (car things)
           things (cdr things)))
  (or things it))

; invokes 'f for each element of 'things, last element processed first
; ( "r" in "eachr" = "rightmost first" )
(def eachr (f things)
  (eachl f (rev things)))

; assign (cons x things) to things
(mac push (x things) `(= ,things (cons ,x ,things)))

; flatten the given list, transforming each leaf-item, recursively
(def flatmap (f things)
     (let acc nil
          (rfnwith flattenize (x things)
                   (if (pair? x)
                       (eachr flattenize x)
                       x
                       (push (f x) acc)))
          acc))

(def flatmap-helper (f things res)
  (loop (pair? things)
    (let a (car things)
      (= res
         (if (pair? a)
             (flatmap-helper f a res)
             a
             (cdr-set res (cons (f a)))
             res)
         things
         (cdr things))))
  (if things
      (= res (set-cdr res (f things))))
  res)

(def flatmap (f things)
  (let res (cons)
    (flatmap-helper f things res)
    (cdr res)))

; flatten the given list, recursively
(def flatten (things) (flatmap x1 things))

; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
; a 'key, returns the list (kx vx) from 'al where kx is equal to 'key
; #attribution: inspiration from arc.arc
(def assoc (key al)
  (if (pair? al)
      (if (caris key (car al))
          (car al)
          (assoc key (cdr al)))))

; given a list 'al of form '( (k0 v0) (k1 v1) (k2 v2) ... (kn vn) ) and
; a 'key, returns vx from 'al where kx is equal to 'key
; #attribution: lifted almost directly from arc.arc
(def alref (key al) (cadr (assoc key al)))
