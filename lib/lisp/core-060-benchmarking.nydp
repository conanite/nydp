(def bm-cond ()
  (if (< 3 5) "less" "more"))

(def bm-cond-lex (var)
  (if var "present" "absent"))

(def bm-cond-3 ()
  (bm-cond-lex 1)
  (bm-cond-lex nil))

(def bm-pythag ()
  (for i 1 50
    (for j 1 50
      (sqrt (+ (* i i) (* j j))))))

(def bm-repeat (f n)
  (for b 1 n (f)))

(def bm (desc f repeats iterations)
     (p "\n================================================")
     (p "Benchmark: ~desc - ~repeats runs of ~iterations iterations each")
     (let times 0
          (for reps 1 repeats
               (let started (time)
                    (bm-repeat f iterations)
                    (let elapsed (- (time) started)
                         (assign times (+ elapsed times))
                         (p "  took: ~elapsed ms, ~(/ elapsed iterations) ms per iteration"))))
          (p "total ~(just times), average ~(/ times repeats) per run")
          (p "================================================\n")
          "~desc : total ~(just times), average ~(/ times repeats) per run"))

;; (assign a 1)
;; (assign b 1)

;; (def bm-add-globals () (+ a b))

;; (def bm-lc-0 () 0)
;; (def bm-lc-1 (a) a)
;; (def bm-lc-2 (a b) (a b))
;; (def bm-lc-3 (a b c) (a b c))
;; (def bm-lc-4 (a b c d) (a b c d))

;; (def bm-lc-0R a a)
;; (def bm-lc-1R (a . b) (apply a b))
;; (def bm-lc-2R (a b . c) (apply a b c))
;; (def bm-lc-3R (a b c . d) (apply a b c d))
;; (def bm-lc-4R (a b c d . e) (apply a b c d e))

;; (def bm-plus-0 () (+))
;; (def bm-plus-1 (a) (+ a))
;; (def bm-plus-2 (a b) (+ a b))
;; (def bm-plus-3 (a b c) (+ a b c))
;; (def bm-f-1 (a) (a))
;; (def bm-f-2 (a b) (a b))
;; (def bm-f-3 (a b c) (a b c))

;; (def bm-0-arg-times-call () (*))
;; (def bm-1-arg-times-call () (* 23))
;; (def bm-2-arg-times-call () (* 23 24))
;; (def bm-3-arg-times-call () (* 23 24 25))
;; (def bm-4-arg-times-call () (* 23 24 25 26))

;; (def bm-plus-0-call () (bm-plus-0))
;; (def bm-plus-1-call () (bm-plus-1 1))
;; (def bm-plus-2-call () (bm-plus-2 1 2))
;; (def bm-plus-3-call () (bm-plus-3 1 2 3))
;; (def bm-f-1-call () (for i 0 10 (bm-f-1 +)))
;; (def bm-f-2-call () (for i 0 10 (bm-f-2 + 2)))
;; (def bm-f-3-call () (for i 0 10 (bm-f-3 + 2 3)))

;; (def bm-0-lc-call () (bm-lc-0))
;; (def bm-1-lc-call () (bm-lc-1 +))
;; (def bm-2-lc-call () (bm-lc-2 + 1))
;; (def bm-3-lc-call () (bm-lc-3 + 1 2))
;; (def bm-4-lc-call () (bm-lc-4 + 1 2 3))

;; (def bm-0R-lc-call () (bm-lc-0R +))
;; (def bm-1R-lc-call () (bm-lc-1R + 1))
;; (def bm-2R-lc-call () (bm-lc-2R + 1 2))
;; (def bm-3R-lc-call () (bm-lc-3R + 1 2 3))
;; (def bm-4R-lc-call () (bm-lc-4R + 1 2 3 4))

;; (def bm-complicated-0 (a b c) (a (+ 1 b) (+ 1 c)))

;; (def bm-complicated ()
;;   (bm-complicated-0 +
;;                     (bm-complicated-0 * 3 (bm-complicated-0 + 3 6))
;;                     (bm-complicated-0 - 10 (bm-complicated-0 - 13 8))))

;; (def bm-pre-compile-test ()
;;   (for i 1 10
;;        (pre-compile (dox-src rbs))))

;; (def bm-hash-fill
;;   (let h {}
;;     (=h.aa 1) (=h.ab 2) (=h.ac 3) (=h.ba 4) (=h.bb 5) (=h.bc 6)
;;     (=h.ca 1) (=h.cb 2) (=h.cc 3) (=h.ca 4) (=h.cb 5) (=h.cc 6)
;;     (=h.da 1) (=h.db 2) (=h.dc 3) (=h.da 4) (=h.db 5) (=h.dc 6)
;;     (=h.aa 1) (=h.ab 2) (=h.ac 3) (=h.ba 4) (=h.bb 5) (=h.bc 6)
;;     (=h.ca 1) (=h.cb 2) (=h.cc 3) (=h.ca 4) (=h.cb 5) (=h.cc 6)
;;     (=h.da 1) (=h.db 2) (=h.dc 3) (=h.da 4) (=h.db 5) (=h.dc 6)
;;     (list (list h.aa h.ab h.ac h.ba h.bb h.bc)
;;           (list h.aa h.ab h.ac h.ba h.bb h.bc)
;;           (list h.ca h.cb h.cc h.ca h.cb h.cc)
;;           (list h.da h.db h.dc h.da h.db h.dc)
;;           (list h.aa h.ab h.ac h.ba h.bb h.bc)
;;           (list h.ca h.cb h.cc h.ca h.cb h.cc)
;;           (list h.da h.db h.dc h.da h.db h.dc)
;;           (list h.da h.ab h.ac h.ba h.bb h.bc))))

(def rbs (name)
  (let summary nil
    (push (bm "cond               "   bm-cond-3             10   100000) summary)
    ;; (push (bm "pythag              "   bm-pythag            5       10) summary)
    ;; (push (bm "recursive           "   bm-complicated       5     1000) summary)
    ;; (push (bm "global vars         "   bm-add-globals      10    50000) summary)
    ;; (push (bm "0 arg times         "   bm-0-arg-times-call 10    50000) summary)
    ;; (push (bm "1 arg times         "   bm-1-arg-times-call 10    50000) summary)
    ;; (push (bm "2 arg times         "   bm-2-arg-times-call 10    50000) summary)
    ;; (push (bm "SYM                 "   bm-plus-0-call      10    50000) summary)
    ;; (push (bm "SYM LEX             "   bm-plus-1-call      10    50000) summary)
    ;; (push (bm "SYM LEX LEX         "   bm-plus-2-call      10    50000) summary)
    ;; (push (bm "SYM LEX LEX LEX     "   bm-plus-3-call      10    50000) summary)
    ;; (push (bm "3 arg times         "   bm-3-arg-times-call 10   100000) summary)
    ;; (push (bm "4 arg times         "   bm-4-arg-times-call 10   100000) summary)
    ;; (push (bm "0R arg lexical-vars "   bm-0R-lc-call       10    50000) summary)
    ;; (push (bm "1R arg lexical-vars "   bm-1R-lc-call       10    50000) summary)
    ;; (push (bm "2R arg lexical-vars "   bm-2R-lc-call       10    50000) summary)
    ;; (push (bm "3R arg lexical-vars "   bm-3R-lc-call       10    50000) summary)
    ;; (push (bm "4R arg lexical-vars "   bm-4R-lc-call       10    50000) summary)
    ;; (push (bm "0 arg lexical-vars  "   bm-0-lc-call        10    50000) summary)
    ;; (push (bm "1 arg lexical-vars  "   bm-1-lc-call        10    50000) summary)
    ;; (push (bm "2 arg lexical-vars  "   bm-2-lc-call        10    50000) summary)
    ;; (push (bm "3 arg lexical-vars  "   bm-3-lc-call        10    50000) summary)
    ;; (push (bm "4 arg lexical-vars  "   bm-4-lc-call        10    50000) summary)
    ;; (push (bm "hashing             "   bm-hash-fill        10   200000) summary)
    ;; (push (bm "pre-compile         "   bm-pre-compile-test 10    10000) summary)
    ;; (push (bm "LEX         "   bm-f-1-call 10    10000) summary)
    ;; (push (bm "LEX LEX     "   bm-f-2-call 10    10000) summary)
    ;; (push (bm "LEX LEX LEX "   bm-f-3-call 10    10000) summary)
    (each s summary (p name " " s))))
