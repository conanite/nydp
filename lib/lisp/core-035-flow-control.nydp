(chapter-start 'flow-control "constructs for looping and error management")

(mac on-err (handler . body)
  ; executes 'body. If an error is raised, executes 'handler. Inside
  ; 'handler, the parameter 'errors is a list of error messages extracted from
  ; the sequence of errors that led here (Exception#cause in ruby or Throwable.getCause() in java)
  `(handle-error (fn (errors) ,handler)
                 (fn ()       ,@body)))

(mac ensure (protection . body)
  ; executes 'body. Afterwards, executes 'protection.
  ; 'protection is always executed even if there is an error.
  `(ensuring (fn () ,protection)
             (fn ()    ,@body)))

(mac while (test . body)
  ; tests 'test, as long as 'test is non-nil,
  ; repeatedly executes 'body
  (w/uniq (rfname pred)
    `(rfnwith ,rfname (,pred ,test)
        (when ,pred
          ,@body
          (,rfname ,test)))))

(mac loop (start test update . body)
  ; execute 'start, then for as long as 'test returns non-nil,
  ; execute 'body and 'update
  (w/uniq (gfn gparm)
    `(do ,start
         ((rfn ,gfn (,gparm)
            (if ,gparm
                (do ,@body ,update (,gfn ,test))))
          ,test))))

(mac for (v init max . body)
  ; assign 'init to 'v, then execute 'body 'max times,
  ; incrementing 'v at each iteration
  (w/uniq (gi gm)
    `(with (,v nil ,gi ,init ,gm (+ ,max 1))
       (loop (assign ,v ,gi) (< ,v ,gm) (assign ,v (+ ,v 1))
         ,@body))))

;; return a new function which is the original function with
;; the given args1 already applied
;; arguments to the new function are whatever arguments remain
;; for the old function
;; Could be (mac curry things `(fn args (apply ,@things args))) but less readable
(mac curry (f . args0)
  `(fn args
       (apply ,f ,@args0 args)))

;; like curry, but the returned function takes only a single arg (assumes all
;; args but one are provided here)
;; Could be (mac curry1 things `(fn (arg) (,@things arg))) but less readable
(mac curry1 (f . args)
  `(fn (arg)
       (,f ,@args arg)))

(mac cache-get (hsh key val)
  ; if ,key is already in ,hsh - return the associated value.
  ; if ,key is not already in ,hsh - evaluate ,val, store the result
  ; under ,key in ,hsh, and return it
  (w/uniq (h k v)
          `(with (,h ,hsh ,k ,key)
                 (let ,v (hash-get ,h ,k)
                   (or ,v (returnlet ,v ,val (hash-set ,h ,k ,v)))))))

(mac defmemo (name args . body)
  ; same as 'def, but caches the result, keyed on args, so for a given set of args the result
  ; is only ever calculated once
  (let forms (filter-forms (build-def-hash (hash)) body)
    (w/uniq h
            `(let ,h (hash)
               (def ,name ,args
                 ,@(map (fn (c) (cons 'comment c)) forms.comment)
                 ,@(map (fn (c) (cons 'chapter c)) forms.chapter)
                 (cache-get ,h (list ,@args) (do ,@(hash-get forms nil))))))))
